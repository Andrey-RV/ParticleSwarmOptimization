<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pso API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pso</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import numpy as np
from typing import Sequence, Callable, Any

number = int | float
function_or_number = int | float | Callable[[number], number]
sequence_of_tuples = Sequence[tuple[number, number]]
numeric_array = np.ndarray[number, Any]


class Particle():
    def __init__(self, bounds: sequence_of_tuples) -&gt; None:
        r&#34;&#34;&#34;_Instantiates a single particle with a random initial position and initial velocity of 0_.

        Args:
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min and max value for each dimension_.
        &#34;&#34;&#34;
        self.position = np.array([random.uniform(b[0], b[1]) for b in bounds])
        self.velocity = np.array([0.0 for _ in range(len(bounds))])
        self.personal_best_position = self.position.copy()
        self.fitness = float(&#39;inf&#39;)
        self.best_fitness = float(&#39;inf&#39;)

    def update_velocity(self, global_best_position: numeric_array, inertia: function_or_number) -&gt; None:
        r&#34;&#34;&#34;_Updates the velocity accordingly to the following formula_:
            $$\displaystyle v_{i+1} = \omega v_{i} + 2rand()({p_{best}}_{i} - p_{i}) + 2rand()({g_{best}}_{i} - p_{i}) \\$$
            - \(v_{i+1}\): the new velocity \( \\ \)
            - \(v_{i}\): the current velocity \( \\ \)
            - \(\omega\): the inertia weight \( \\ \)
            - \({p_{best}}_{i}\): the personal best position of the particle \( \\ \)
            - \(p_{i}\): the current position of the particle \( \\ \)
            - \({g_{best}}_{i}\): the global best position of the swarm \( \\ \)
            - \(rand()\): a random number between 0 and 1 \( \\ \)

        Args:
            global_best_position (np.ndarray[int or float]): _An array containing the global best position of the swarm for each dimension_
            inertia (int or float or Callable): _The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight_
        &#34;&#34;&#34;
        num_dimensions = len(self.position)
        for curr_dim in range(num_dimensions):
            p, g = random.uniform(0, 1), random.uniform(0, 1)
            self.velocity[curr_dim] = (
                                       inertia * (self.velocity[curr_dim])
                                       + 2 * p * (self.personal_best_position[curr_dim] - self.position[curr_dim])
                                       + 2 * g * (global_best_position[curr_dim] - self.position[curr_dim])
                                      )

    def update_position(self, bounds: sequence_of_tuples) -&gt; None:
        r&#34;&#34;&#34;_Updates the position of the particle by adding the velocity to the current position.
        It also makes sure that the new position is within the bounds of the search space_.

        Args:
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min of max value for each dimension_.
        &#34;&#34;&#34;
        num_dimensions = len(self.position)
        for curr_dim in range(num_dimensions):
            self.position[curr_dim] += self.velocity[curr_dim]
            self.position[curr_dim] = max(self.position[curr_dim], bounds[curr_dim][0])
            self.position[curr_dim] = min(self.position[curr_dim], bounds[curr_dim][1])

    def evaluate_fitness(self, function: Callable[[numeric_array], number]) -&gt; None:
        r&#34;&#34;&#34;_Evaluates the fitness of the particle by passing its position to the objective function
        and updating the personal best position and fitness if the new fitness is better than the current one_.

        Args:
            function (Callable[np.ndarray[int or float]], int or float]): _The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle_
        &#34;&#34;&#34;
        self.fitness = function(self.position)
        if self.fitness &lt; self.best_fitness:
            self.best_fitness = self.fitness
            self.personal_best_position = self.position


class ParticleSwarmOptimization():
    def __init__(self, function: Callable[[numeric_array], number], inertia_weight: function_or_number,
                 bounds: sequence_of_tuples, num_particles: int, max_iter: int) -&gt; None:
        r&#34;&#34;&#34;_Instantiates a particle swarm optimization algorithm_.

        Args:
            function (Callable[np.ndarray[int or float]], int or float]): _The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle_
            inertia_weight (int or float or Callable): _The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight_
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min of max value for each dimension_.
            num_particles (int): _The number of particles in the swarm_
            max_iter (int): _The maximum number of iterations_
        &#34;&#34;&#34;
        self.function = function
        self.inertia = inertia_weight
        self.bounds = bounds
        self.num_particles = num_particles
        self.max_iter = max_iter
        self.swarm = [Particle(bounds) for __ in range(num_particles)]
        self.global_best_position = self.swarm[0].position
        self.global_best_fitness = float(&#39;inf&#39;)

    def optimize(self) -&gt; None:
        &#34;&#34;&#34;_Runs the optimization algorithm for the specified number of iterations. For each iteration, it updates the velocity and position of each particle and updates the global best position and fitness if the new fitness is better than the current one_.
        &#34;&#34;&#34;
        for iteration in range(self.max_iter):
            for particle in self.swarm:
                particle.evaluate_fitness(self.function)
                if particle.fitness &lt; self.global_best_fitness:
                    self.global_best_fitness = particle.fitness
                    self.global_best_position = particle.position
            inertia = self.inertia(iteration) if callable(self.inertia) else self.inertia

            for particle in self.swarm:
                particle.update_velocity(self.global_best_position, inertia)
                particle.update_position(self.bounds)

    @property
    def get_best_position(self) -&gt; numeric_array:
        &#34;&#34;&#34;_Returns the global best position of the swarm_.

        Returns:
            np.ndarray[int or float]: _An array containing the global best position of the swarm for each dimension_
        &#34;&#34;&#34;
        return self.global_best_position

    @property
    def get_best_fitness(self) -&gt; number:
        &#34;&#34;&#34;_Returns the global best fitness of the swarm. If the algorithm doesn&#39;t get stuck in a local minimum,
        this should be the global minimum of the objective function_.

        Returns:
            int or float: _The global best fitness of the swarm_
        &#34;&#34;&#34;
        return self.global_best_fitness</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pso.Particle"><code class="flex name class">
<span>class <span class="ident">Particle</span></span>
<span>(</span><span>bounds: Sequence[tuple[int | float, int | float]])</span>
</code></dt>
<dd>
<div class="desc"><p><em>Instantiates a single particle with a random initial position and initial velocity of 0</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bounds</code></strong> :&ensp;<code>Sequence[tuple[int</code> or <code>float, int</code> or <code>float]</code></dt>
<dd><em>The limits of the search space for each dimension, the sequence should be of the form <span><span class="MathJax_Preview">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</span><script type="math/tex">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</script></span>, each tuple representing the min and max value for each dimension</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Particle():
    def __init__(self, bounds: sequence_of_tuples) -&gt; None:
        r&#34;&#34;&#34;_Instantiates a single particle with a random initial position and initial velocity of 0_.

        Args:
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min and max value for each dimension_.
        &#34;&#34;&#34;
        self.position = np.array([random.uniform(b[0], b[1]) for b in bounds])
        self.velocity = np.array([0.0 for _ in range(len(bounds))])
        self.personal_best_position = self.position.copy()
        self.fitness = float(&#39;inf&#39;)
        self.best_fitness = float(&#39;inf&#39;)

    def update_velocity(self, global_best_position: numeric_array, inertia: function_or_number) -&gt; None:
        r&#34;&#34;&#34;_Updates the velocity accordingly to the following formula_:
            $$\displaystyle v_{i+1} = \omega v_{i} + 2rand()({p_{best}}_{i} - p_{i}) + 2rand()({g_{best}}_{i} - p_{i}) \\$$
            - \(v_{i+1}\): the new velocity \( \\ \)
            - \(v_{i}\): the current velocity \( \\ \)
            - \(\omega\): the inertia weight \( \\ \)
            - \({p_{best}}_{i}\): the personal best position of the particle \( \\ \)
            - \(p_{i}\): the current position of the particle \( \\ \)
            - \({g_{best}}_{i}\): the global best position of the swarm \( \\ \)
            - \(rand()\): a random number between 0 and 1 \( \\ \)

        Args:
            global_best_position (np.ndarray[int or float]): _An array containing the global best position of the swarm for each dimension_
            inertia (int or float or Callable): _The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight_
        &#34;&#34;&#34;
        num_dimensions = len(self.position)
        for curr_dim in range(num_dimensions):
            p, g = random.uniform(0, 1), random.uniform(0, 1)
            self.velocity[curr_dim] = (
                                       inertia * (self.velocity[curr_dim])
                                       + 2 * p * (self.personal_best_position[curr_dim] - self.position[curr_dim])
                                       + 2 * g * (global_best_position[curr_dim] - self.position[curr_dim])
                                      )

    def update_position(self, bounds: sequence_of_tuples) -&gt; None:
        r&#34;&#34;&#34;_Updates the position of the particle by adding the velocity to the current position.
        It also makes sure that the new position is within the bounds of the search space_.

        Args:
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min of max value for each dimension_.
        &#34;&#34;&#34;
        num_dimensions = len(self.position)
        for curr_dim in range(num_dimensions):
            self.position[curr_dim] += self.velocity[curr_dim]
            self.position[curr_dim] = max(self.position[curr_dim], bounds[curr_dim][0])
            self.position[curr_dim] = min(self.position[curr_dim], bounds[curr_dim][1])

    def evaluate_fitness(self, function: Callable[[numeric_array], number]) -&gt; None:
        r&#34;&#34;&#34;_Evaluates the fitness of the particle by passing its position to the objective function
        and updating the personal best position and fitness if the new fitness is better than the current one_.

        Args:
            function (Callable[np.ndarray[int or float]], int or float]): _The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle_
        &#34;&#34;&#34;
        self.fitness = function(self.position)
        if self.fitness &lt; self.best_fitness:
            self.best_fitness = self.fitness
            self.personal_best_position = self.position</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pso.Particle.evaluate_fitness"><code class="name flex">
<span>def <span class="ident">evaluate_fitness</span></span>(<span>self, function: Callable[[numpy.ndarray[int | float, Any]], int | float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><em>Evaluates the fitness of the particle by passing its position to the objective function
and updating the personal best position and fitness if the new fitness is better than the current one</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Callable[np.ndarray[int</code> or <code>float]], int</code> or <code>float]</code></dt>
<dd><em>The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_fitness(self, function: Callable[[numeric_array], number]) -&gt; None:
    r&#34;&#34;&#34;_Evaluates the fitness of the particle by passing its position to the objective function
    and updating the personal best position and fitness if the new fitness is better than the current one_.

    Args:
        function (Callable[np.ndarray[int or float]], int or float]): _The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle_
    &#34;&#34;&#34;
    self.fitness = function(self.position)
    if self.fitness &lt; self.best_fitness:
        self.best_fitness = self.fitness
        self.personal_best_position = self.position</code></pre>
</details>
</dd>
<dt id="pso.Particle.update_position"><code class="name flex">
<span>def <span class="ident">update_position</span></span>(<span>self, bounds: Sequence[tuple[int | float, int | float]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><em>Updates the position of the particle by adding the velocity to the current position.
It also makes sure that the new position is within the bounds of the search space</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bounds</code></strong> :&ensp;<code>Sequence[tuple[int</code> or <code>float, int</code> or <code>float]</code></dt>
<dd><em>The limits of the search space for each dimension, the sequence should be of the form <span><span class="MathJax_Preview">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</span><script type="math/tex">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</script></span>, each tuple representing the min of max value for each dimension</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_position(self, bounds: sequence_of_tuples) -&gt; None:
    r&#34;&#34;&#34;_Updates the position of the particle by adding the velocity to the current position.
    It also makes sure that the new position is within the bounds of the search space_.

    Args:
        bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min of max value for each dimension_.
    &#34;&#34;&#34;
    num_dimensions = len(self.position)
    for curr_dim in range(num_dimensions):
        self.position[curr_dim] += self.velocity[curr_dim]
        self.position[curr_dim] = max(self.position[curr_dim], bounds[curr_dim][0])
        self.position[curr_dim] = min(self.position[curr_dim], bounds[curr_dim][1])</code></pre>
</details>
</dd>
<dt id="pso.Particle.update_velocity"><code class="name flex">
<span>def <span class="ident">update_velocity</span></span>(<span>self, global_best_position: numpy.ndarray[int | float, typing.Any], inertia: Union[int, float, Callable[[int | float], int | float]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><em>Updates the velocity accordingly to the following formula</em>:
<span><span class="MathJax_Preview">\displaystyle v_{i+1} = \omega v_{i} + 2rand()({p_{best}}_{i} - p_{i}) + 2rand()({g_{best}}_{i} - p_{i}) \\</span><script type="math/tex; mode=display">\displaystyle v_{i+1} = \omega v_{i} + 2rand()({p_{best}}_{i} - p_{i}) + 2rand()({g_{best}}_{i} - p_{i}) \\</script></span>
- <span><span class="MathJax_Preview">v_{i+1}</span><script type="math/tex">v_{i+1}</script></span>: the new velocity <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">v_{i}</span><script type="math/tex">v_{i}</script></span>: the current velocity <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>: the inertia weight <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">{p_{best}}_{i}</span><script type="math/tex">{p_{best}}_{i}</script></span>: the personal best position of the particle <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">p_{i}</span><script type="math/tex">p_{i}</script></span>: the current position of the particle <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">{g_{best}}_{i}</span><script type="math/tex">{g_{best}}_{i}</script></span>: the global best position of the swarm <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span>
- <span><span class="MathJax_Preview">rand()</span><script type="math/tex">rand()</script></span>: a random number between 0 and 1 <span><span class="MathJax_Preview"> \\ </span><script type="math/tex"> \\ </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_best_position</code></strong> :&ensp;<code>np.ndarray[int</code> or <code>float]</code></dt>
<dd><em>An array containing the global best position of the swarm for each dimension</em></dd>
<dt><strong><code>inertia</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>Callable</code></dt>
<dd><em>The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_velocity(self, global_best_position: numeric_array, inertia: function_or_number) -&gt; None:
    r&#34;&#34;&#34;_Updates the velocity accordingly to the following formula_:
        $$\displaystyle v_{i+1} = \omega v_{i} + 2rand()({p_{best}}_{i} - p_{i}) + 2rand()({g_{best}}_{i} - p_{i}) \\$$
        - \(v_{i+1}\): the new velocity \( \\ \)
        - \(v_{i}\): the current velocity \( \\ \)
        - \(\omega\): the inertia weight \( \\ \)
        - \({p_{best}}_{i}\): the personal best position of the particle \( \\ \)
        - \(p_{i}\): the current position of the particle \( \\ \)
        - \({g_{best}}_{i}\): the global best position of the swarm \( \\ \)
        - \(rand()\): a random number between 0 and 1 \( \\ \)

    Args:
        global_best_position (np.ndarray[int or float]): _An array containing the global best position of the swarm for each dimension_
        inertia (int or float or Callable): _The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight_
    &#34;&#34;&#34;
    num_dimensions = len(self.position)
    for curr_dim in range(num_dimensions):
        p, g = random.uniform(0, 1), random.uniform(0, 1)
        self.velocity[curr_dim] = (
                                   inertia * (self.velocity[curr_dim])
                                   + 2 * p * (self.personal_best_position[curr_dim] - self.position[curr_dim])
                                   + 2 * g * (global_best_position[curr_dim] - self.position[curr_dim])
                                  )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pso.ParticleSwarmOptimization"><code class="flex name class">
<span>class <span class="ident">ParticleSwarmOptimization</span></span>
<span>(</span><span>function: Callable[[numpy.ndarray[int | float, Any]], int | float], inertia_weight: Union[int, float, Callable[[int | float], int | float]], bounds: Sequence[tuple[int | float, int | float]], num_particles: int, max_iter: int)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Instantiates a particle swarm optimization algorithm</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Callable[np.ndarray[int</code> or <code>float]], int</code> or <code>float]</code></dt>
<dd><em>The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle</em></dd>
<dt><strong><code>inertia_weight</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>Callable</code></dt>
<dd><em>The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight</em></dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>Sequence[tuple[int</code> or <code>float, int</code> or <code>float]</code></dt>
<dd><em>The limits of the search space for each dimension, the sequence should be of the form <span><span class="MathJax_Preview">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</span><script type="math/tex">[({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]</script></span>, each tuple representing the min of max value for each dimension</em>.</dd>
<dt><strong><code>num_particles</code></strong> :&ensp;<code>int</code></dt>
<dd><em>The number of particles in the swarm</em></dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd><em>The maximum number of iterations</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParticleSwarmOptimization():
    def __init__(self, function: Callable[[numeric_array], number], inertia_weight: function_or_number,
                 bounds: sequence_of_tuples, num_particles: int, max_iter: int) -&gt; None:
        r&#34;&#34;&#34;_Instantiates a particle swarm optimization algorithm_.

        Args:
            function (Callable[np.ndarray[int or float]], int or float]): _The objective function. It should take an array containing the position of the particle for each dimension and return a single real number representing the fitness of the particle_
            inertia_weight (int or float or Callable): _The inertia weight, if a callable is passed, it should take the current iteration as an argument and return the inertia weight_
            bounds (Sequence[tuple[int or float, int or float]): _The limits of the search space for each dimension, the sequence should be of the form \([({x_1}_{min}, {x_1}_{max}), ({x_2}_{min}, {x_2}_{max}), \cdots]\), each tuple representing the min of max value for each dimension_.
            num_particles (int): _The number of particles in the swarm_
            max_iter (int): _The maximum number of iterations_
        &#34;&#34;&#34;
        self.function = function
        self.inertia = inertia_weight
        self.bounds = bounds
        self.num_particles = num_particles
        self.max_iter = max_iter
        self.swarm = [Particle(bounds) for __ in range(num_particles)]
        self.global_best_position = self.swarm[0].position
        self.global_best_fitness = float(&#39;inf&#39;)

    def optimize(self) -&gt; None:
        &#34;&#34;&#34;_Runs the optimization algorithm for the specified number of iterations. For each iteration, it updates the velocity and position of each particle and updates the global best position and fitness if the new fitness is better than the current one_.
        &#34;&#34;&#34;
        for iteration in range(self.max_iter):
            for particle in self.swarm:
                particle.evaluate_fitness(self.function)
                if particle.fitness &lt; self.global_best_fitness:
                    self.global_best_fitness = particle.fitness
                    self.global_best_position = particle.position
            inertia = self.inertia(iteration) if callable(self.inertia) else self.inertia

            for particle in self.swarm:
                particle.update_velocity(self.global_best_position, inertia)
                particle.update_position(self.bounds)

    @property
    def get_best_position(self) -&gt; numeric_array:
        &#34;&#34;&#34;_Returns the global best position of the swarm_.

        Returns:
            np.ndarray[int or float]: _An array containing the global best position of the swarm for each dimension_
        &#34;&#34;&#34;
        return self.global_best_position

    @property
    def get_best_fitness(self) -&gt; number:
        &#34;&#34;&#34;_Returns the global best fitness of the swarm. If the algorithm doesn&#39;t get stuck in a local minimum,
        this should be the global minimum of the objective function_.

        Returns:
            int or float: _The global best fitness of the swarm_
        &#34;&#34;&#34;
        return self.global_best_fitness</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pso.ParticleSwarmOptimization.get_best_fitness"><code class="name">var <span class="ident">get_best_fitness</span> : int | float</code></dt>
<dd>
<div class="desc"><p><em>Returns the global best fitness of the swarm. If the algorithm doesn't get stuck in a local minimum,
this should be the global minimum of the objective function</em>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code></dt>
<dd><em>The global best fitness of the swarm</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def get_best_fitness(self) -&gt; number:
    &#34;&#34;&#34;_Returns the global best fitness of the swarm. If the algorithm doesn&#39;t get stuck in a local minimum,
    this should be the global minimum of the objective function_.

    Returns:
        int or float: _The global best fitness of the swarm_
    &#34;&#34;&#34;
    return self.global_best_fitness</code></pre>
</details>
</dd>
<dt id="pso.ParticleSwarmOptimization.get_best_position"><code class="name">var <span class="ident">get_best_position</span> : numpy.ndarray[int | float, typing.Any]</code></dt>
<dd>
<div class="desc"><p><em>Returns the global best position of the swarm</em>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray[int</code> or <code>float]</code></dt>
<dd><em>An array containing the global best position of the swarm for each dimension</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def get_best_position(self) -&gt; numeric_array:
    &#34;&#34;&#34;_Returns the global best position of the swarm_.

    Returns:
        np.ndarray[int or float]: _An array containing the global best position of the swarm for each dimension_
    &#34;&#34;&#34;
    return self.global_best_position</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pso.ParticleSwarmOptimization.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><em>Runs the optimization algorithm for the specified number of iterations. For each iteration, it updates the velocity and position of each particle and updates the global best position and fitness if the new fitness is better than the current one</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(self) -&gt; None:
    &#34;&#34;&#34;_Runs the optimization algorithm for the specified number of iterations. For each iteration, it updates the velocity and position of each particle and updates the global best position and fitness if the new fitness is better than the current one_.
    &#34;&#34;&#34;
    for iteration in range(self.max_iter):
        for particle in self.swarm:
            particle.evaluate_fitness(self.function)
            if particle.fitness &lt; self.global_best_fitness:
                self.global_best_fitness = particle.fitness
                self.global_best_position = particle.position
        inertia = self.inertia(iteration) if callable(self.inertia) else self.inertia

        for particle in self.swarm:
            particle.update_velocity(self.global_best_position, inertia)
            particle.update_position(self.bounds)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pso.Particle" href="#pso.Particle">Particle</a></code></h4>
<ul class="">
<li><code><a title="pso.Particle.evaluate_fitness" href="#pso.Particle.evaluate_fitness">evaluate_fitness</a></code></li>
<li><code><a title="pso.Particle.update_position" href="#pso.Particle.update_position">update_position</a></code></li>
<li><code><a title="pso.Particle.update_velocity" href="#pso.Particle.update_velocity">update_velocity</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pso.ParticleSwarmOptimization" href="#pso.ParticleSwarmOptimization">ParticleSwarmOptimization</a></code></h4>
<ul class="">
<li><code><a title="pso.ParticleSwarmOptimization.get_best_fitness" href="#pso.ParticleSwarmOptimization.get_best_fitness">get_best_fitness</a></code></li>
<li><code><a title="pso.ParticleSwarmOptimization.get_best_position" href="#pso.ParticleSwarmOptimization.get_best_position">get_best_position</a></code></li>
<li><code><a title="pso.ParticleSwarmOptimization.optimize" href="#pso.ParticleSwarmOptimization.optimize">optimize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>